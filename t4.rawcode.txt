public void setFixedHeight(boolean fixedHeight){   mSizeCalculator.setFixedHeight(fixedHeight); } 
public void setMaxRowHeight(int maxRowHeight){   mSizeCalculator.setMaxRowHeight(maxRowHeight); } 
private int preFillGrid(Direction direction,int dy,int emptyTop,RecyclerView.Recycler recycler,RecyclerView.State state){   int newFirstVisiblePosition=firstChildPositionForRow(mFirstVisibleRow);   SparseArray<View> viewCache=new SparseArray<>(getChildCount());   int startLeftOffset=getPaddingLeft();   int startTopOffset=getPaddingTop() + emptyTop;   if (getChildCount() != 0) {     startTopOffset=getDecoratedTop(getChildAt(0));     if (mFirstVisiblePosition != newFirstVisiblePosition) { switch (direction) { case UP:         double previousTopRowHeight=sizeForChildAtPosition(mFirstVisiblePosition - 1).getHeight();       startTopOffset-=previousTopRowHeight;     break; case DOWN:   double topRowHeight=sizeForChildAtPosition(mFirstVisiblePosition).getHeight(); startTopOffset+=topRowHeight; break; } } for (int i=0; i < getChildCount(); i++) { int position=mFirstVisiblePosition + i; final View child=getChildAt(i); viewCache.put(position,child); } for (int i=0; i < viewCache.size(); i++) { final View cachedView=viewCache.valueAt(i); detachView(cachedView); } } mFirstVisiblePosition=newFirstVisiblePosition; int leftOffset=startLeftOffset; int topOffset=startTopOffset + mPendingScrollPositionOffset; int nextPosition=mFirstVisiblePosition; int currentRow=0; while (nextPosition >= 0 && nextPosition < state.getItemCount()) { boolean isViewCached=true; View view=viewCache.get(nextPosition); if (view == null) { view=recycler.getViewForPosition(nextPosition); isViewCached=false; } if (mIsFirstViewHeader && nextPosition == HEADER_POSITION) { measureChildWithMargins(view,0,0); mHeaderViewSize=new Size(view.getMeasuredWidth(),view.getMeasuredHeight()); } Size viewSize=sizeForChildAtPosition(nextPosition); if ((leftOffset + viewSize.getWidth()) > getContentWidth()) { if (currentRow + 1 == mRowsLimit) break; currentRow++; leftOffset=startLeftOffset; Size previousViewSize=sizeForChildAtPosition(nextPosition - 1); topOffset+=previousViewSize.getHeight(); } boolean isAtEndOfContent; switch (direction) { case DOWN: isAtEndOfContent=topOffset >= getContentHeight() + dy; break; default : isAtEndOfContent=topOffset >= getContentHeight(); break; } if (isAtEndOfContent) break; if (isViewCached) { attachView(view); viewCache.remove(nextPosition); }  else { addView(view); measureChildWithMargins(view,0,0); int right=leftOffset + viewSize.getWidth(); int bottom=topOffset + viewSize.getHeight(); layoutDecorated(view,leftOffset,topOffset,right,bottom); } leftOffset+=viewSize.getWidth(); nextPosition++; } for (int i=0; i < viewCache.size(); i++) { final View removingView=viewCache.valueAt(i); recycler.recycleView(removingView); } int pixelsFilled=0; if (getChildCount() > 0) { pixelsFilled=getChildAt(getChildCount() - 1).getBottom(); } return pixelsFilled; } 
